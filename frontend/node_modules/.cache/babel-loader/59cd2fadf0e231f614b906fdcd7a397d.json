{"ast":null,"code":"/* eslint no-underscore-dangle: \"off\" */\n\n/* eslint no-use-before-define: \"off\" */\nimport { getDocument } from 'ssr-window';\nexport default function Autoplay(_ref) {\n  let {\n    swiper,\n    extendParams,\n    on,\n    emit,\n    params\n  } = _ref;\n  swiper.autoplay = {\n    running: false,\n    paused: false,\n    timeLeft: 0\n  };\n  extendParams({\n    autoplay: {\n      enabled: false,\n      delay: 3000,\n      waitForTransition: true,\n      disableOnInteraction: true,\n      stopOnLastSlide: false,\n      reverseDirection: false,\n      pauseOnMouseEnter: false\n    }\n  });\n  let timeout;\n  let raf;\n  let autoplayDelayTotal = params && params.autoplay ? params.autoplay.delay : 3000;\n  let autoplayDelayCurrent = params && params.autoplay ? params.autoplay.delay : 3000;\n  let autoplayTimeLeft;\n  let autoplayStartTime = new Date().getTime;\n  let wasPaused;\n  let isTouched;\n  let pausedByTouch;\n  let touchStartTimeout;\n  let slideChanged;\n  let pausedByInteraction;\n\n  function onTransitionEnd(e) {\n    if (!swiper || swiper.destroyed || !swiper.wrapperEl) return;\n    if (e.target !== swiper.wrapperEl) return;\n    swiper.wrapperEl.removeEventListener('transitionend', onTransitionEnd);\n    resume();\n  }\n\n  const calcTimeLeft = () => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n\n    if (swiper.autoplay.paused) {\n      wasPaused = true;\n    } else if (wasPaused) {\n      autoplayDelayCurrent = autoplayTimeLeft;\n      wasPaused = false;\n    }\n\n    const timeLeft = swiper.autoplay.paused ? autoplayTimeLeft : autoplayStartTime + autoplayDelayCurrent - new Date().getTime();\n    swiper.autoplay.timeLeft = timeLeft;\n    emit('autoplayTimeLeft', timeLeft, timeLeft / autoplayDelayTotal);\n    raf = requestAnimationFrame(() => {\n      calcTimeLeft();\n    });\n  };\n\n  const getSlideDelay = () => {\n    let activeSlideEl;\n\n    if (swiper.virtual && swiper.params.virtual.enabled) {\n      activeSlideEl = swiper.slides.filter(slideEl => slideEl.classList.contains('swiper-slide-active'))[0];\n    } else {\n      activeSlideEl = swiper.slides[swiper.activeIndex];\n    }\n\n    if (!activeSlideEl) return undefined;\n    const currentSlideDelay = parseInt(activeSlideEl.getAttribute('data-swiper-autoplay'), 10);\n    return currentSlideDelay;\n  };\n\n  const run = delayForce => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    cancelAnimationFrame(raf);\n    calcTimeLeft();\n    let delay = typeof delayForce === 'undefined' ? swiper.params.autoplay.delay : delayForce;\n    autoplayDelayTotal = swiper.params.autoplay.delay;\n    autoplayDelayCurrent = swiper.params.autoplay.delay;\n    const currentSlideDelay = getSlideDelay();\n\n    if (!Number.isNaN(currentSlideDelay) && currentSlideDelay > 0 && typeof delayForce === 'undefined') {\n      delay = currentSlideDelay;\n      autoplayDelayTotal = currentSlideDelay;\n      autoplayDelayCurrent = currentSlideDelay;\n    }\n\n    autoplayTimeLeft = delay;\n    const speed = swiper.params.speed;\n\n    const proceed = () => {\n      if (!swiper || swiper.destroyed) return;\n\n      if (swiper.params.autoplay.reverseDirection) {\n        if (!swiper.isBeginning || swiper.params.loop || swiper.params.rewind) {\n          swiper.slidePrev(speed, true, true);\n          emit('autoplay');\n        } else if (!swiper.params.autoplay.stopOnLastSlide) {\n          swiper.slideTo(swiper.slides.length - 1, speed, true, true);\n          emit('autoplay');\n        }\n      } else {\n        if (!swiper.isEnd || swiper.params.loop || swiper.params.rewind) {\n          swiper.slideNext(speed, true, true);\n          emit('autoplay');\n        } else if (!swiper.params.autoplay.stopOnLastSlide) {\n          swiper.slideTo(0, speed, true, true);\n          emit('autoplay');\n        }\n      }\n\n      if (swiper.params.cssMode) {\n        autoplayStartTime = new Date().getTime();\n        requestAnimationFrame(() => {\n          run();\n        });\n      }\n    };\n\n    if (delay > 0) {\n      clearTimeout(timeout);\n      timeout = setTimeout(() => {\n        proceed();\n      }, delay);\n    } else {\n      requestAnimationFrame(() => {\n        proceed();\n      });\n    } // eslint-disable-next-line\n\n\n    return delay;\n  };\n\n  const start = () => {\n    swiper.autoplay.running = true;\n    run();\n    emit('autoplayStart');\n  };\n\n  const stop = () => {\n    swiper.autoplay.running = false;\n    clearTimeout(timeout);\n    cancelAnimationFrame(raf);\n    emit('autoplayStop');\n  };\n\n  const pause = (internal, reset) => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    clearTimeout(timeout);\n\n    if (!internal) {\n      pausedByInteraction = true;\n    }\n\n    const proceed = () => {\n      emit('autoplayPause');\n\n      if (swiper.params.autoplay.waitForTransition) {\n        swiper.wrapperEl.addEventListener('transitionend', onTransitionEnd);\n      } else {\n        resume();\n      }\n    };\n\n    swiper.autoplay.paused = true;\n\n    if (reset) {\n      if (slideChanged) {\n        autoplayTimeLeft = swiper.params.autoplay.delay;\n      }\n\n      slideChanged = false;\n      proceed();\n      return;\n    }\n\n    const delay = autoplayTimeLeft || swiper.params.autoplay.delay;\n    autoplayTimeLeft = delay - (new Date().getTime() - autoplayStartTime);\n    if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop) return;\n    if (autoplayTimeLeft < 0) autoplayTimeLeft = 0;\n    proceed();\n  };\n\n  const resume = () => {\n    if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop || swiper.destroyed || !swiper.autoplay.running) return;\n    autoplayStartTime = new Date().getTime();\n\n    if (pausedByInteraction) {\n      pausedByInteraction = false;\n      run(autoplayTimeLeft);\n    } else {\n      run();\n    }\n\n    swiper.autoplay.paused = false;\n    emit('autoplayResume');\n  };\n\n  const onVisibilityChange = () => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    const document = getDocument();\n\n    if (document.visibilityState === 'hidden') {\n      pausedByInteraction = true;\n      pause(true);\n    }\n\n    if (document.visibilityState === 'visible') {\n      resume();\n    }\n  };\n\n  const onPointerEnter = e => {\n    if (e.pointerType !== 'mouse') return;\n    pausedByInteraction = true;\n    pause(true);\n  };\n\n  const onPointerLeave = e => {\n    if (e.pointerType !== 'mouse') return;\n\n    if (swiper.autoplay.paused) {\n      resume();\n    }\n  };\n\n  const attachMouseEvents = () => {\n    if (swiper.params.autoplay.pauseOnMouseEnter) {\n      swiper.el.addEventListener('pointerenter', onPointerEnter);\n      swiper.el.addEventListener('pointerleave', onPointerLeave);\n    }\n  };\n\n  const detachMouseEvents = () => {\n    swiper.el.removeEventListener('pointerenter', onPointerEnter);\n    swiper.el.removeEventListener('pointerleave', onPointerLeave);\n  };\n\n  const attachDocumentEvents = () => {\n    const document = getDocument();\n    document.addEventListener('visibilitychange', onVisibilityChange);\n  };\n\n  const detachDocumentEvents = () => {\n    const document = getDocument();\n    document.removeEventListener('visibilitychange', onVisibilityChange);\n  };\n\n  on('init', () => {\n    if (swiper.params.autoplay.enabled) {\n      attachMouseEvents();\n      attachDocumentEvents();\n      autoplayStartTime = new Date().getTime();\n      start();\n    }\n  });\n  on('destroy', () => {\n    detachMouseEvents();\n    detachDocumentEvents();\n\n    if (swiper.autoplay.running) {\n      stop();\n    }\n  });\n  on('beforeTransitionStart', (_s, speed, internal) => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n\n    if (internal || !swiper.params.autoplay.disableOnInteraction) {\n      pause(true, true);\n    } else {\n      stop();\n    }\n  });\n  on('sliderFirstMove', () => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n\n    if (swiper.params.autoplay.disableOnInteraction) {\n      stop();\n      return;\n    }\n\n    isTouched = true;\n    pausedByTouch = false;\n    pausedByInteraction = false;\n    touchStartTimeout = setTimeout(() => {\n      pausedByInteraction = true;\n      pausedByTouch = true;\n      pause(true);\n    }, 200);\n  });\n  on('touchEnd', () => {\n    if (swiper.destroyed || !swiper.autoplay.running || !isTouched) return;\n    clearTimeout(touchStartTimeout);\n    clearTimeout(timeout);\n\n    if (swiper.params.autoplay.disableOnInteraction) {\n      pausedByTouch = false;\n      isTouched = false;\n      return;\n    }\n\n    if (pausedByTouch && swiper.params.cssMode) resume();\n    pausedByTouch = false;\n    isTouched = false;\n  });\n  on('slideChange', () => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    slideChanged = true;\n  });\n  Object.assign(swiper.autoplay, {\n    start,\n    stop,\n    pause,\n    resume\n  });\n}","map":{"version":3,"sources":["C:/Users/Santushti/Desktop/santushti/Shop-Ease/node_modules/swiper/modules/autoplay/autoplay.js"],"names":["getDocument","Autoplay","swiper","extendParams","on","emit","params","autoplay","running","paused","timeLeft","enabled","delay","waitForTransition","disableOnInteraction","stopOnLastSlide","reverseDirection","pauseOnMouseEnter","timeout","raf","autoplayDelayTotal","autoplayDelayCurrent","autoplayTimeLeft","autoplayStartTime","Date","getTime","wasPaused","isTouched","pausedByTouch","touchStartTimeout","slideChanged","pausedByInteraction","onTransitionEnd","e","destroyed","wrapperEl","target","removeEventListener","resume","calcTimeLeft","requestAnimationFrame","getSlideDelay","activeSlideEl","virtual","slides","filter","slideEl","classList","contains","activeIndex","undefined","currentSlideDelay","parseInt","getAttribute","run","delayForce","cancelAnimationFrame","Number","isNaN","speed","proceed","isBeginning","loop","rewind","slidePrev","slideTo","length","isEnd","slideNext","cssMode","clearTimeout","setTimeout","start","stop","pause","internal","reset","addEventListener","onVisibilityChange","document","visibilityState","onPointerEnter","pointerType","onPointerLeave","attachMouseEvents","el","detachMouseEvents","attachDocumentEvents","detachDocumentEvents","_s","Object","assign"],"mappings":"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","sourcesContent":["/* eslint no-underscore-dangle: \"off\" */\n/* eslint no-use-before-define: \"off\" */\nimport { getDocument } from 'ssr-window';\nexport default function Autoplay({\n  swiper,\n  extendParams,\n  on,\n  emit,\n  params\n}) {\n  swiper.autoplay = {\n    running: false,\n    paused: false,\n    timeLeft: 0\n  };\n  extendParams({\n    autoplay: {\n      enabled: false,\n      delay: 3000,\n      waitForTransition: true,\n      disableOnInteraction: true,\n      stopOnLastSlide: false,\n      reverseDirection: false,\n      pauseOnMouseEnter: false\n    }\n  });\n  let timeout;\n  let raf;\n  let autoplayDelayTotal = params && params.autoplay ? params.autoplay.delay : 3000;\n  let autoplayDelayCurrent = params && params.autoplay ? params.autoplay.delay : 3000;\n  let autoplayTimeLeft;\n  let autoplayStartTime = new Date().getTime;\n  let wasPaused;\n  let isTouched;\n  let pausedByTouch;\n  let touchStartTimeout;\n  let slideChanged;\n  let pausedByInteraction;\n  function onTransitionEnd(e) {\n    if (!swiper || swiper.destroyed || !swiper.wrapperEl) return;\n    if (e.target !== swiper.wrapperEl) return;\n    swiper.wrapperEl.removeEventListener('transitionend', onTransitionEnd);\n    resume();\n  }\n  const calcTimeLeft = () => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    if (swiper.autoplay.paused) {\n      wasPaused = true;\n    } else if (wasPaused) {\n      autoplayDelayCurrent = autoplayTimeLeft;\n      wasPaused = false;\n    }\n    const timeLeft = swiper.autoplay.paused ? autoplayTimeLeft : autoplayStartTime + autoplayDelayCurrent - new Date().getTime();\n    swiper.autoplay.timeLeft = timeLeft;\n    emit('autoplayTimeLeft', timeLeft, timeLeft / autoplayDelayTotal);\n    raf = requestAnimationFrame(() => {\n      calcTimeLeft();\n    });\n  };\n  const getSlideDelay = () => {\n    let activeSlideEl;\n    if (swiper.virtual && swiper.params.virtual.enabled) {\n      activeSlideEl = swiper.slides.filter(slideEl => slideEl.classList.contains('swiper-slide-active'))[0];\n    } else {\n      activeSlideEl = swiper.slides[swiper.activeIndex];\n    }\n    if (!activeSlideEl) return undefined;\n    const currentSlideDelay = parseInt(activeSlideEl.getAttribute('data-swiper-autoplay'), 10);\n    return currentSlideDelay;\n  };\n  const run = delayForce => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    cancelAnimationFrame(raf);\n    calcTimeLeft();\n    let delay = typeof delayForce === 'undefined' ? swiper.params.autoplay.delay : delayForce;\n    autoplayDelayTotal = swiper.params.autoplay.delay;\n    autoplayDelayCurrent = swiper.params.autoplay.delay;\n    const currentSlideDelay = getSlideDelay();\n    if (!Number.isNaN(currentSlideDelay) && currentSlideDelay > 0 && typeof delayForce === 'undefined') {\n      delay = currentSlideDelay;\n      autoplayDelayTotal = currentSlideDelay;\n      autoplayDelayCurrent = currentSlideDelay;\n    }\n    autoplayTimeLeft = delay;\n    const speed = swiper.params.speed;\n    const proceed = () => {\n      if (!swiper || swiper.destroyed) return;\n      if (swiper.params.autoplay.reverseDirection) {\n        if (!swiper.isBeginning || swiper.params.loop || swiper.params.rewind) {\n          swiper.slidePrev(speed, true, true);\n          emit('autoplay');\n        } else if (!swiper.params.autoplay.stopOnLastSlide) {\n          swiper.slideTo(swiper.slides.length - 1, speed, true, true);\n          emit('autoplay');\n        }\n      } else {\n        if (!swiper.isEnd || swiper.params.loop || swiper.params.rewind) {\n          swiper.slideNext(speed, true, true);\n          emit('autoplay');\n        } else if (!swiper.params.autoplay.stopOnLastSlide) {\n          swiper.slideTo(0, speed, true, true);\n          emit('autoplay');\n        }\n      }\n      if (swiper.params.cssMode) {\n        autoplayStartTime = new Date().getTime();\n        requestAnimationFrame(() => {\n          run();\n        });\n      }\n    };\n    if (delay > 0) {\n      clearTimeout(timeout);\n      timeout = setTimeout(() => {\n        proceed();\n      }, delay);\n    } else {\n      requestAnimationFrame(() => {\n        proceed();\n      });\n    }\n\n    // eslint-disable-next-line\n    return delay;\n  };\n  const start = () => {\n    swiper.autoplay.running = true;\n    run();\n    emit('autoplayStart');\n  };\n  const stop = () => {\n    swiper.autoplay.running = false;\n    clearTimeout(timeout);\n    cancelAnimationFrame(raf);\n    emit('autoplayStop');\n  };\n  const pause = (internal, reset) => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    clearTimeout(timeout);\n    if (!internal) {\n      pausedByInteraction = true;\n    }\n    const proceed = () => {\n      emit('autoplayPause');\n      if (swiper.params.autoplay.waitForTransition) {\n        swiper.wrapperEl.addEventListener('transitionend', onTransitionEnd);\n      } else {\n        resume();\n      }\n    };\n    swiper.autoplay.paused = true;\n    if (reset) {\n      if (slideChanged) {\n        autoplayTimeLeft = swiper.params.autoplay.delay;\n      }\n      slideChanged = false;\n      proceed();\n      return;\n    }\n    const delay = autoplayTimeLeft || swiper.params.autoplay.delay;\n    autoplayTimeLeft = delay - (new Date().getTime() - autoplayStartTime);\n    if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop) return;\n    if (autoplayTimeLeft < 0) autoplayTimeLeft = 0;\n    proceed();\n  };\n  const resume = () => {\n    if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop || swiper.destroyed || !swiper.autoplay.running) return;\n    autoplayStartTime = new Date().getTime();\n    if (pausedByInteraction) {\n      pausedByInteraction = false;\n      run(autoplayTimeLeft);\n    } else {\n      run();\n    }\n    swiper.autoplay.paused = false;\n    emit('autoplayResume');\n  };\n  const onVisibilityChange = () => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    const document = getDocument();\n    if (document.visibilityState === 'hidden') {\n      pausedByInteraction = true;\n      pause(true);\n    }\n    if (document.visibilityState === 'visible') {\n      resume();\n    }\n  };\n  const onPointerEnter = e => {\n    if (e.pointerType !== 'mouse') return;\n    pausedByInteraction = true;\n    pause(true);\n  };\n  const onPointerLeave = e => {\n    if (e.pointerType !== 'mouse') return;\n    if (swiper.autoplay.paused) {\n      resume();\n    }\n  };\n  const attachMouseEvents = () => {\n    if (swiper.params.autoplay.pauseOnMouseEnter) {\n      swiper.el.addEventListener('pointerenter', onPointerEnter);\n      swiper.el.addEventListener('pointerleave', onPointerLeave);\n    }\n  };\n  const detachMouseEvents = () => {\n    swiper.el.removeEventListener('pointerenter', onPointerEnter);\n    swiper.el.removeEventListener('pointerleave', onPointerLeave);\n  };\n  const attachDocumentEvents = () => {\n    const document = getDocument();\n    document.addEventListener('visibilitychange', onVisibilityChange);\n  };\n  const detachDocumentEvents = () => {\n    const document = getDocument();\n    document.removeEventListener('visibilitychange', onVisibilityChange);\n  };\n  on('init', () => {\n    if (swiper.params.autoplay.enabled) {\n      attachMouseEvents();\n      attachDocumentEvents();\n      autoplayStartTime = new Date().getTime();\n      start();\n    }\n  });\n  on('destroy', () => {\n    detachMouseEvents();\n    detachDocumentEvents();\n    if (swiper.autoplay.running) {\n      stop();\n    }\n  });\n  on('beforeTransitionStart', (_s, speed, internal) => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    if (internal || !swiper.params.autoplay.disableOnInteraction) {\n      pause(true, true);\n    } else {\n      stop();\n    }\n  });\n  on('sliderFirstMove', () => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    if (swiper.params.autoplay.disableOnInteraction) {\n      stop();\n      return;\n    }\n    isTouched = true;\n    pausedByTouch = false;\n    pausedByInteraction = false;\n    touchStartTimeout = setTimeout(() => {\n      pausedByInteraction = true;\n      pausedByTouch = true;\n      pause(true);\n    }, 200);\n  });\n  on('touchEnd', () => {\n    if (swiper.destroyed || !swiper.autoplay.running || !isTouched) return;\n    clearTimeout(touchStartTimeout);\n    clearTimeout(timeout);\n    if (swiper.params.autoplay.disableOnInteraction) {\n      pausedByTouch = false;\n      isTouched = false;\n      return;\n    }\n    if (pausedByTouch && swiper.params.cssMode) resume();\n    pausedByTouch = false;\n    isTouched = false;\n  });\n  on('slideChange', () => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    slideChanged = true;\n  });\n  Object.assign(swiper.autoplay, {\n    start,\n    stop,\n    pause,\n    resume\n  });\n}"]},"metadata":{},"sourceType":"module"}