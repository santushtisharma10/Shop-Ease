{"ast":null,"code":"import { elementChildren, elementOuterSize, elementStyle, setCSSProperty } from '../../shared/utils.js';\nexport default function updateSlides() {\n  const swiper = this;\n\n  function getDirectionLabel(property) {\n    if (swiper.isHorizontal()) {\n      return property;\n    } // prettier-ignore\n\n\n    return {\n      'width': 'height',\n      'margin-top': 'margin-left',\n      'margin-bottom ': 'margin-right',\n      'margin-left': 'margin-top',\n      'margin-right': 'margin-bottom',\n      'padding-left': 'padding-top',\n      'padding-right': 'padding-bottom',\n      'marginRight': 'marginBottom'\n    }[property];\n  }\n\n  function getDirectionPropertyValue(node, label) {\n    return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);\n  }\n\n  const params = swiper.params;\n  const {\n    wrapperEl,\n    slidesEl,\n    size: swiperSize,\n    rtlTranslate: rtl,\n    wrongRTL\n  } = swiper;\n  const isVirtual = swiper.virtual && params.virtual.enabled;\n  const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;\n  const slides = elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);\n  const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;\n  let snapGrid = [];\n  const slidesGrid = [];\n  const slidesSizesGrid = [];\n  let offsetBefore = params.slidesOffsetBefore;\n\n  if (typeof offsetBefore === 'function') {\n    offsetBefore = params.slidesOffsetBefore.call(swiper);\n  }\n\n  let offsetAfter = params.slidesOffsetAfter;\n\n  if (typeof offsetAfter === 'function') {\n    offsetAfter = params.slidesOffsetAfter.call(swiper);\n  }\n\n  const previousSnapGridLength = swiper.snapGrid.length;\n  const previousSlidesGridLength = swiper.slidesGrid.length;\n  let spaceBetween = params.spaceBetween;\n  let slidePosition = -offsetBefore;\n  let prevSlideSize = 0;\n  let index = 0;\n\n  if (typeof swiperSize === 'undefined') {\n    return;\n  }\n\n  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n    spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;\n  }\n\n  swiper.virtualSize = -spaceBetween; // reset margins\n\n  slides.forEach(slideEl => {\n    if (rtl) {\n      slideEl.style.marginLeft = '';\n    } else {\n      slideEl.style.marginRight = '';\n    }\n\n    slideEl.style.marginBottom = '';\n    slideEl.style.marginTop = '';\n  }); // reset cssMode offsets\n\n  if (params.centeredSlides && params.cssMode) {\n    setCSSProperty(wrapperEl, '--swiper-centered-offset-before', '');\n    setCSSProperty(wrapperEl, '--swiper-centered-offset-after', '');\n  }\n\n  const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;\n\n  if (gridEnabled) {\n    swiper.grid.initSlides(slidesLength);\n  } // Calc slides\n\n\n  let slideSize;\n  const shouldResetSlideSize = params.slidesPerView === 'auto' && params.breakpoints && Object.keys(params.breakpoints).filter(key => {\n    return typeof params.breakpoints[key].slidesPerView !== 'undefined';\n  }).length > 0;\n\n  for (let i = 0; i < slidesLength; i += 1) {\n    slideSize = 0;\n    let slide;\n    if (slides[i]) slide = slides[i];\n\n    if (gridEnabled) {\n      swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);\n    }\n\n    if (slides[i] && elementStyle(slide, 'display') === 'none') continue; // eslint-disable-line\n\n    if (params.slidesPerView === 'auto') {\n      if (shouldResetSlideSize) {\n        slides[i].style[getDirectionLabel('width')] = ``;\n      }\n\n      const slideStyles = getComputedStyle(slide);\n      const currentTransform = slide.style.transform;\n      const currentWebKitTransform = slide.style.webkitTransform;\n\n      if (currentTransform) {\n        slide.style.transform = 'none';\n      }\n\n      if (currentWebKitTransform) {\n        slide.style.webkitTransform = 'none';\n      }\n\n      if (params.roundLengths) {\n        slideSize = swiper.isHorizontal() ? elementOuterSize(slide, 'width', true) : elementOuterSize(slide, 'height', true);\n      } else {\n        // eslint-disable-next-line\n        const width = getDirectionPropertyValue(slideStyles, 'width');\n        const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');\n        const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');\n        const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');\n        const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');\n        const boxSizing = slideStyles.getPropertyValue('box-sizing');\n\n        if (boxSizing && boxSizing === 'border-box') {\n          slideSize = width + marginLeft + marginRight;\n        } else {\n          const {\n            clientWidth,\n            offsetWidth\n          } = slide;\n          slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);\n        }\n      }\n\n      if (currentTransform) {\n        slide.style.transform = currentTransform;\n      }\n\n      if (currentWebKitTransform) {\n        slide.style.webkitTransform = currentWebKitTransform;\n      }\n\n      if (params.roundLengths) slideSize = Math.floor(slideSize);\n    } else {\n      slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;\n      if (params.roundLengths) slideSize = Math.floor(slideSize);\n\n      if (slides[i]) {\n        slides[i].style[getDirectionLabel('width')] = `${slideSize}px`;\n      }\n    }\n\n    if (slides[i]) {\n      slides[i].swiperSlideSize = slideSize;\n    }\n\n    slidesSizesGrid.push(slideSize);\n\n    if (params.centeredSlides) {\n      slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;\n      if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n      if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n      if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;\n      if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n      if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n      slidesGrid.push(slidePosition);\n    } else {\n      if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n      if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n      slidesGrid.push(slidePosition);\n      slidePosition = slidePosition + slideSize + spaceBetween;\n    }\n\n    swiper.virtualSize += slideSize + spaceBetween;\n    prevSlideSize = slideSize;\n    index += 1;\n  }\n\n  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;\n\n  if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {\n    wrapperEl.style.width = `${swiper.virtualSize + params.spaceBetween}px`;\n  }\n\n  if (params.setWrapperSize) {\n    wrapperEl.style[getDirectionLabel('width')] = `${swiper.virtualSize + params.spaceBetween}px`;\n  }\n\n  if (gridEnabled) {\n    swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);\n  } // Remove last grid elements depending on width\n\n\n  if (!params.centeredSlides) {\n    const newSlidesGrid = [];\n\n    for (let i = 0; i < snapGrid.length; i += 1) {\n      let slidesGridItem = snapGrid[i];\n      if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n\n      if (snapGrid[i] <= swiper.virtualSize - swiperSize) {\n        newSlidesGrid.push(slidesGridItem);\n      }\n    }\n\n    snapGrid = newSlidesGrid;\n\n    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {\n      snapGrid.push(swiper.virtualSize - swiperSize);\n    }\n  }\n\n  if (isVirtual && params.loop) {\n    const size = slidesSizesGrid[0] + spaceBetween;\n\n    if (params.slidesPerGroup > 1) {\n      const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);\n      const groupSize = size * params.slidesPerGroup;\n\n      for (let i = 0; i < groups; i += 1) {\n        snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);\n      }\n    }\n\n    for (let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1) {\n      if (params.slidesPerGroup === 1) {\n        snapGrid.push(snapGrid[snapGrid.length - 1] + size);\n      }\n\n      slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);\n      swiper.virtualSize += size;\n    }\n  }\n\n  if (snapGrid.length === 0) snapGrid = [0];\n\n  if (params.spaceBetween !== 0) {\n    const key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');\n    slides.filter((_, slideIndex) => {\n      if (!params.cssMode || params.loop) return true;\n\n      if (slideIndex === slides.length - 1) {\n        return false;\n      }\n\n      return true;\n    }).forEach(slideEl => {\n      slideEl.style[key] = `${spaceBetween}px`;\n    });\n  }\n\n  if (params.centeredSlides && params.centeredSlidesBounds) {\n    let allSlidesSize = 0;\n    slidesSizesGrid.forEach(slideSizeValue => {\n      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);\n    });\n    allSlidesSize -= params.spaceBetween;\n    const maxSnap = allSlidesSize - swiperSize;\n    snapGrid = snapGrid.map(snap => {\n      if (snap < 0) return -offsetBefore;\n      if (snap > maxSnap) return maxSnap + offsetAfter;\n      return snap;\n    });\n  }\n\n  if (params.centerInsufficientSlides) {\n    let allSlidesSize = 0;\n    slidesSizesGrid.forEach(slideSizeValue => {\n      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);\n    });\n    allSlidesSize -= params.spaceBetween;\n\n    if (allSlidesSize < swiperSize) {\n      const allSlidesOffset = (swiperSize - allSlidesSize) / 2;\n      snapGrid.forEach((snap, snapIndex) => {\n        snapGrid[snapIndex] = snap - allSlidesOffset;\n      });\n      slidesGrid.forEach((snap, snapIndex) => {\n        slidesGrid[snapIndex] = snap + allSlidesOffset;\n      });\n    }\n  }\n\n  Object.assign(swiper, {\n    slides,\n    snapGrid,\n    slidesGrid,\n    slidesSizesGrid\n  });\n\n  if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {\n    setCSSProperty(wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);\n    setCSSProperty(wrapperEl, '--swiper-centered-offset-after', `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);\n    const addToSnapGrid = -swiper.snapGrid[0];\n    const addToSlidesGrid = -swiper.slidesGrid[0];\n    swiper.snapGrid = swiper.snapGrid.map(v => v + addToSnapGrid);\n    swiper.slidesGrid = swiper.slidesGrid.map(v => v + addToSlidesGrid);\n  }\n\n  if (slidesLength !== previousSlidesLength) {\n    swiper.emit('slidesLengthChange');\n  }\n\n  if (snapGrid.length !== previousSnapGridLength) {\n    if (swiper.params.watchOverflow) swiper.checkOverflow();\n    swiper.emit('snapGridLengthChange');\n  }\n\n  if (slidesGrid.length !== previousSlidesGridLength) {\n    swiper.emit('slidesGridLengthChange');\n  }\n\n  if (params.watchSlidesProgress) {\n    swiper.updateSlidesOffset();\n  }\n\n  if (!isVirtual && !params.cssMode && (params.effect === 'slide' || params.effect === 'fade')) {\n    const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;\n    const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);\n\n    if (slidesLength <= params.maxBackfaceHiddenSlides) {\n      if (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);\n    } else if (hasClassBackfaceClassAdded) {\n      swiper.el.classList.remove(backFaceHiddenClass);\n    }\n  }\n}","map":{"version":3,"sources":["C:/Users/Santushti/Desktop/santushti/Shop-Ease/node_modules/swiper/core/update/updateSlides.js"],"names":["elementChildren","elementOuterSize","elementStyle","setCSSProperty","updateSlides","swiper","getDirectionLabel","property","isHorizontal","getDirectionPropertyValue","node","label","parseFloat","getPropertyValue","params","wrapperEl","slidesEl","size","swiperSize","rtlTranslate","rtl","wrongRTL","isVirtual","virtual","enabled","previousSlidesLength","slides","length","slideClass","slidesLength","snapGrid","slidesGrid","slidesSizesGrid","offsetBefore","slidesOffsetBefore","call","offsetAfter","slidesOffsetAfter","previousSnapGridLength","previousSlidesGridLength","spaceBetween","slidePosition","prevSlideSize","index","indexOf","replace","virtualSize","forEach","slideEl","style","marginLeft","marginRight","marginBottom","marginTop","centeredSlides","cssMode","gridEnabled","grid","rows","initSlides","slideSize","shouldResetSlideSize","slidesPerView","breakpoints","Object","keys","filter","key","i","slide","updateSlide","slideStyles","getComputedStyle","currentTransform","transform","currentWebKitTransform","webkitTransform","roundLengths","width","paddingLeft","paddingRight","boxSizing","clientWidth","offsetWidth","Math","floor","swiperSlideSize","push","abs","slidesPerGroup","min","slidesPerGroupSkip","max","effect","setWrapperSize","updateWrapperSize","newSlidesGrid","slidesGridItem","loop","groups","ceil","slidesBefore","slidesAfter","groupSize","_","slideIndex","centeredSlidesBounds","allSlidesSize","slideSizeValue","maxSnap","map","snap","centerInsufficientSlides","allSlidesOffset","snapIndex","assign","addToSnapGrid","addToSlidesGrid","v","emit","watchOverflow","checkOverflow","watchSlidesProgress","updateSlidesOffset","backFaceHiddenClass","containerModifierClass","hasClassBackfaceClassAdded","el","classList","contains","maxBackfaceHiddenSlides","add","remove"],"mappings":"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","sourcesContent":["import { elementChildren, elementOuterSize, elementStyle, setCSSProperty } from '../../shared/utils.js';\nexport default function updateSlides() {\n  const swiper = this;\n  function getDirectionLabel(property) {\n    if (swiper.isHorizontal()) {\n      return property;\n    }\n    // prettier-ignore\n    return {\n      'width': 'height',\n      'margin-top': 'margin-left',\n      'margin-bottom ': 'margin-right',\n      'margin-left': 'margin-top',\n      'margin-right': 'margin-bottom',\n      'padding-left': 'padding-top',\n      'padding-right': 'padding-bottom',\n      'marginRight': 'marginBottom'\n    }[property];\n  }\n  function getDirectionPropertyValue(node, label) {\n    return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);\n  }\n  const params = swiper.params;\n  const {\n    wrapperEl,\n    slidesEl,\n    size: swiperSize,\n    rtlTranslate: rtl,\n    wrongRTL\n  } = swiper;\n  const isVirtual = swiper.virtual && params.virtual.enabled;\n  const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;\n  const slides = elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);\n  const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;\n  let snapGrid = [];\n  const slidesGrid = [];\n  const slidesSizesGrid = [];\n  let offsetBefore = params.slidesOffsetBefore;\n  if (typeof offsetBefore === 'function') {\n    offsetBefore = params.slidesOffsetBefore.call(swiper);\n  }\n  let offsetAfter = params.slidesOffsetAfter;\n  if (typeof offsetAfter === 'function') {\n    offsetAfter = params.slidesOffsetAfter.call(swiper);\n  }\n  const previousSnapGridLength = swiper.snapGrid.length;\n  const previousSlidesGridLength = swiper.slidesGrid.length;\n  let spaceBetween = params.spaceBetween;\n  let slidePosition = -offsetBefore;\n  let prevSlideSize = 0;\n  let index = 0;\n  if (typeof swiperSize === 'undefined') {\n    return;\n  }\n  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n    spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;\n  }\n  swiper.virtualSize = -spaceBetween;\n\n  // reset margins\n  slides.forEach(slideEl => {\n    if (rtl) {\n      slideEl.style.marginLeft = '';\n    } else {\n      slideEl.style.marginRight = '';\n    }\n    slideEl.style.marginBottom = '';\n    slideEl.style.marginTop = '';\n  });\n\n  // reset cssMode offsets\n  if (params.centeredSlides && params.cssMode) {\n    setCSSProperty(wrapperEl, '--swiper-centered-offset-before', '');\n    setCSSProperty(wrapperEl, '--swiper-centered-offset-after', '');\n  }\n  const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;\n  if (gridEnabled) {\n    swiper.grid.initSlides(slidesLength);\n  }\n\n  // Calc slides\n  let slideSize;\n  const shouldResetSlideSize = params.slidesPerView === 'auto' && params.breakpoints && Object.keys(params.breakpoints).filter(key => {\n    return typeof params.breakpoints[key].slidesPerView !== 'undefined';\n  }).length > 0;\n  for (let i = 0; i < slidesLength; i += 1) {\n    slideSize = 0;\n    let slide;\n    if (slides[i]) slide = slides[i];\n    if (gridEnabled) {\n      swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);\n    }\n    if (slides[i] && elementStyle(slide, 'display') === 'none') continue; // eslint-disable-line\n\n    if (params.slidesPerView === 'auto') {\n      if (shouldResetSlideSize) {\n        slides[i].style[getDirectionLabel('width')] = ``;\n      }\n      const slideStyles = getComputedStyle(slide);\n      const currentTransform = slide.style.transform;\n      const currentWebKitTransform = slide.style.webkitTransform;\n      if (currentTransform) {\n        slide.style.transform = 'none';\n      }\n      if (currentWebKitTransform) {\n        slide.style.webkitTransform = 'none';\n      }\n      if (params.roundLengths) {\n        slideSize = swiper.isHorizontal() ? elementOuterSize(slide, 'width', true) : elementOuterSize(slide, 'height', true);\n      } else {\n        // eslint-disable-next-line\n        const width = getDirectionPropertyValue(slideStyles, 'width');\n        const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');\n        const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');\n        const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');\n        const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');\n        const boxSizing = slideStyles.getPropertyValue('box-sizing');\n        if (boxSizing && boxSizing === 'border-box') {\n          slideSize = width + marginLeft + marginRight;\n        } else {\n          const {\n            clientWidth,\n            offsetWidth\n          } = slide;\n          slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);\n        }\n      }\n      if (currentTransform) {\n        slide.style.transform = currentTransform;\n      }\n      if (currentWebKitTransform) {\n        slide.style.webkitTransform = currentWebKitTransform;\n      }\n      if (params.roundLengths) slideSize = Math.floor(slideSize);\n    } else {\n      slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;\n      if (params.roundLengths) slideSize = Math.floor(slideSize);\n      if (slides[i]) {\n        slides[i].style[getDirectionLabel('width')] = `${slideSize}px`;\n      }\n    }\n    if (slides[i]) {\n      slides[i].swiperSlideSize = slideSize;\n    }\n    slidesSizesGrid.push(slideSize);\n    if (params.centeredSlides) {\n      slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;\n      if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n      if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n      if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;\n      if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n      if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n      slidesGrid.push(slidePosition);\n    } else {\n      if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n      if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n      slidesGrid.push(slidePosition);\n      slidePosition = slidePosition + slideSize + spaceBetween;\n    }\n    swiper.virtualSize += slideSize + spaceBetween;\n    prevSlideSize = slideSize;\n    index += 1;\n  }\n  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;\n  if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {\n    wrapperEl.style.width = `${swiper.virtualSize + params.spaceBetween}px`;\n  }\n  if (params.setWrapperSize) {\n    wrapperEl.style[getDirectionLabel('width')] = `${swiper.virtualSize + params.spaceBetween}px`;\n  }\n  if (gridEnabled) {\n    swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);\n  }\n\n  // Remove last grid elements depending on width\n  if (!params.centeredSlides) {\n    const newSlidesGrid = [];\n    for (let i = 0; i < snapGrid.length; i += 1) {\n      let slidesGridItem = snapGrid[i];\n      if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n      if (snapGrid[i] <= swiper.virtualSize - swiperSize) {\n        newSlidesGrid.push(slidesGridItem);\n      }\n    }\n    snapGrid = newSlidesGrid;\n    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {\n      snapGrid.push(swiper.virtualSize - swiperSize);\n    }\n  }\n  if (isVirtual && params.loop) {\n    const size = slidesSizesGrid[0] + spaceBetween;\n    if (params.slidesPerGroup > 1) {\n      const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);\n      const groupSize = size * params.slidesPerGroup;\n      for (let i = 0; i < groups; i += 1) {\n        snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);\n      }\n    }\n    for (let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1) {\n      if (params.slidesPerGroup === 1) {\n        snapGrid.push(snapGrid[snapGrid.length - 1] + size);\n      }\n      slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);\n      swiper.virtualSize += size;\n    }\n  }\n  if (snapGrid.length === 0) snapGrid = [0];\n  if (params.spaceBetween !== 0) {\n    const key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');\n    slides.filter((_, slideIndex) => {\n      if (!params.cssMode || params.loop) return true;\n      if (slideIndex === slides.length - 1) {\n        return false;\n      }\n      return true;\n    }).forEach(slideEl => {\n      slideEl.style[key] = `${spaceBetween}px`;\n    });\n  }\n  if (params.centeredSlides && params.centeredSlidesBounds) {\n    let allSlidesSize = 0;\n    slidesSizesGrid.forEach(slideSizeValue => {\n      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);\n    });\n    allSlidesSize -= params.spaceBetween;\n    const maxSnap = allSlidesSize - swiperSize;\n    snapGrid = snapGrid.map(snap => {\n      if (snap < 0) return -offsetBefore;\n      if (snap > maxSnap) return maxSnap + offsetAfter;\n      return snap;\n    });\n  }\n  if (params.centerInsufficientSlides) {\n    let allSlidesSize = 0;\n    slidesSizesGrid.forEach(slideSizeValue => {\n      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);\n    });\n    allSlidesSize -= params.spaceBetween;\n    if (allSlidesSize < swiperSize) {\n      const allSlidesOffset = (swiperSize - allSlidesSize) / 2;\n      snapGrid.forEach((snap, snapIndex) => {\n        snapGrid[snapIndex] = snap - allSlidesOffset;\n      });\n      slidesGrid.forEach((snap, snapIndex) => {\n        slidesGrid[snapIndex] = snap + allSlidesOffset;\n      });\n    }\n  }\n  Object.assign(swiper, {\n    slides,\n    snapGrid,\n    slidesGrid,\n    slidesSizesGrid\n  });\n  if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {\n    setCSSProperty(wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);\n    setCSSProperty(wrapperEl, '--swiper-centered-offset-after', `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);\n    const addToSnapGrid = -swiper.snapGrid[0];\n    const addToSlidesGrid = -swiper.slidesGrid[0];\n    swiper.snapGrid = swiper.snapGrid.map(v => v + addToSnapGrid);\n    swiper.slidesGrid = swiper.slidesGrid.map(v => v + addToSlidesGrid);\n  }\n  if (slidesLength !== previousSlidesLength) {\n    swiper.emit('slidesLengthChange');\n  }\n  if (snapGrid.length !== previousSnapGridLength) {\n    if (swiper.params.watchOverflow) swiper.checkOverflow();\n    swiper.emit('snapGridLengthChange');\n  }\n  if (slidesGrid.length !== previousSlidesGridLength) {\n    swiper.emit('slidesGridLengthChange');\n  }\n  if (params.watchSlidesProgress) {\n    swiper.updateSlidesOffset();\n  }\n  if (!isVirtual && !params.cssMode && (params.effect === 'slide' || params.effect === 'fade')) {\n    const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;\n    const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);\n    if (slidesLength <= params.maxBackfaceHiddenSlides) {\n      if (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);\n    } else if (hasClassBackfaceClassAdded) {\n      swiper.el.classList.remove(backFaceHiddenClass);\n    }\n  }\n}"]},"metadata":{},"sourceType":"module"}